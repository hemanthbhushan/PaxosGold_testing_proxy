const ethSigUtil = require("eth-sig-util");
const { inputToConfig } = require("@ethereum-waffle/compiler");
const { expect } = require("chai");
const { Signer } = require("ethers");
const { ethers, network } = require("hardhat");
// private key for token from address
const privateKey = Buffer(
  "43f2ee33c522046e80b67e96ceb84a05b60b9434b0ee2e3ae4b1311b9f5dcc46",
  "hex"
);
// EIP-55 of ethereumjsUtil.bufferToHex(ethereumjsUtil.privateToAddress(privateKey));
const fromAddress = "0xBd2e9CaF03B81e96eE27AD354c579E1310415F39";
const wrongPrivateKey = Buffer(
  "43f2ee33c522046e80b67e96ceb84a05b60b9434b0ee2e3ae4b1311b9f5dcc41",
  "hex"
);


describe("BetaDelegatedTransfer PAXG",()=>{
  let owner,signer1,admin,proxy,impli,impliProxy,signer2,
   executor,
  recipient,
  whitelister,
  bystander;
  const amount = 10;
  const serviceFeeAmount = 1;

 beforeEach(async ()=>{
  [owner,signer1,signer2,admin,executor,recipient,whitelister,bystander] = await ethers.getSigners();

  const Impli = await ethers.getContractFactory("PAXGImplementation",owner.address);

  const Proxy = await ethers.getContractFactory("AdminUpgradeabilityProxy",admin.address);

   impli = await Impli.deploy();
   proxy = await Proxy.connect(admin).deploy(impli.address);

   impliProxy =  impli.attach(proxy.address);
   await impliProxy.connect(owner).initialize();
   await impliProxy.initializeDomainSeparator();
  //  await impliProxy.connect(owner).pause();
  betaDelegatedTransferContext = {
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "verifyingContract", type: "address" }
      ],
      BetaDelegatedTransfer: [
        { name: "to", type: "address" },
        { name: "value", type: "uint256" },
        { name: "serviceFee", type: "uint256" },
        { name: "seq", type: "uint256" },
        { name: "deadline", type: "uint256" }
      ]
    },
    primaryType: "BetaDelegatedTransfer",
    domain: {
      name: "Paxos Gold",
      verifyingContract: impliProxy.address
    }
  };
  await impliProxy. connect(owner).increaseSupply(100);
    // send the tokens to the custom wallet
    // let { receipt } = 
     await impliProxy.transfer(
      fromAddress,
      2 * (amount + serviceFeeAmount),
      
    );
    // let blockNumber = block.timestamp;
    
    let senderBalance = await impliProxy.balanceOf(fromAddress);
    expect(senderBalance).to.be.equal(2 * (amount + serviceFeeAmount));
    let executorBalance = await impliProxy.balanceOf(executor.address);
    expect(executorBalance).to.equal(0);
    let recipientBalance = await impliProxy.balanceOf(recipient.address);
    expect(recipientBalance).to.equal(0);

     // check the seq
     let nextSeq = await impliProxy.nextSeqOf(fromAddress);
    expect(nextSeq).to.equal(0);

     // set the whitelister
     await impliProxy.connect(owner).setBetaDelegateWhitelister(whitelister.address);

     // whitelist the executor address
     await impliProxy.connect(whitelister).whitelistBetaDelegate(executor.address);
 })

it("can do a delegated transfer", async ()=>{
  // delegated transfer message
  let message = {
    to: recipient, value: amount, serviceFee: serviceFeeAmount,seq: 0,deadline: 1661759217 };
// create delegated transfer
   const typedData = {
    betaDelegatedTransferContext,
    message
  };

  // sign the delegated transfer with the token holder address
  const sig = ethSigUtil.signTypedData(privateKey, { data: typedData });

  // commit delegated transfer
  let { to, value, serviceFee, seq, deadline } = message;
  const { logs } = await impliProxy.connect(executor).betaDelegatedTransfer(sig,to,value,serviceFee,seq,deadline);

  // check balances
  senderBalance = await impliProxy.balanceOf(fromAddress);
  expect(senderBalance).to.equal(amount + serviceFeeAmount);
  
  executorBalance = await impliProxy.balanceOf(executor.address);
  expect(executorBalance).to.equal(serviceFeeAmount)
  
  recipientBalance = await impliProxy.balanceOf(recipient.address);
  expect(recipientBalance).to.equal(amount);

  // check seq updated
  nextSeq = await this.token.nextSeqOf(fromAddress);
  expect(nextSeq).to.equal(1);
  

})

 
});

